// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using EODHistoricalData.NET.BusinessObjects;
//
//    var exchangeDetails = ExchangeDetails.FromJson(jsonString);

namespace EODHistoricalData.NET {
  using System;
  using System.Collections.Generic;

  using System.Globalization;
  using Newtonsoft.Json;
  using Newtonsoft.Json.Converters;

  public partial class ExchangeDetails {
    [JsonProperty("Name")]
    public string Name { get; set; }

    [JsonProperty("Code")]
    public string Code { get; set; }

    [JsonProperty("OperatingMIC")]
    public string OperatingMic { get; set; }

    [JsonProperty("Country")]
    public string Country { get; set; }

    [JsonProperty("Currency")]
    public string Currency { get; set; }

    [JsonProperty("Timezone")]
    public string Timezone { get; set; }

    [JsonProperty("ExchangeHolidays")]
    public Dictionary<string, ExchangeHoliday> ExchangeHolidays { get; set; }

    [JsonProperty("isOpen")]
    public bool IsOpen { get; set; }

    [JsonProperty("TradingHours")]
    public TradingHours TradingHours { get; set; }

    [JsonProperty("ActiveTickers")]
    public long ActiveTickers { get; set; }

    [JsonProperty("PreviousDayUpdatedTickers")]
    public long PreviousDayUpdatedTickers { get; set; }

    [JsonProperty("UpdatedTickers")]
    public long UpdatedTickers { get; set; }
  }

  public partial class ExchangeHoliday {
    [JsonProperty("Holiday")]
    public string Holiday { get; set; }

    [JsonProperty("Date")]
    public DateTimeOffset Date { get; set; }

    [JsonProperty("Type")]
    public TypeEnum Type { get; set; }
  }

  public partial class TradingHours {
    [JsonProperty("Open")]
    public DateTimeOffset Open { get; set; }

    [JsonProperty("Close")]
    public DateTimeOffset Close { get; set; }

    [JsonProperty("OpenUTC")]
    public DateTimeOffset OpenUtc { get; set; }

    [JsonProperty("CloseUTC")]
    public DateTimeOffset CloseUtc { get; set; }

    [JsonProperty("WorkingDays")]
    public string WorkingDays { get; set; }
  }

  public enum TypeEnum { Official, Bank };

  public partial class ExchangeDetails {
    public static ExchangeDetails FromJson(string json) => JsonConvert.DeserializeObject<ExchangeDetails>(json, EODHistoricalData.NET.ExchangeDetailsConverter.Settings);
  }

  public static class ExchangeDetailsSerialize {
    public static string ToJson(this ExchangeDetails self) => JsonConvert.SerializeObject(self, EODHistoricalData.NET.ExchangeDetailsConverter.Settings);
  }

  internal static class ExchangeDetailsConverter {
    public static List<string> Errors = new List<string>();
    public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings {
      MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
      DateParseHandling = DateParseHandling.None,
      Converters =
      {
          TypeEnumConverter.Singleton,
          new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal },
          new NullConverter(),
      },
      Error = delegate (object sender, Newtonsoft.Json.Serialization.ErrorEventArgs args) {
        Errors.Add(args.ErrorContext.Error.Message);
        args.ErrorContext.Handled = true;
      },
    };
  }

  internal class TypeEnumConverter : JsonConverter {
    public override bool CanConvert(Type t) => t == typeof(TypeEnum) || t == typeof(TypeEnum?);

    public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer) {
      if (reader.TokenType == JsonToken.Null) return null;
      var value = serializer.Deserialize<string>(reader);
      if (value == "official") {
        return TypeEnum.Official;
      } else if (value == "bank") {
        return TypeEnum.Bank;
      }
      throw new Exception("Cannot unmarshal type TypeEnum");
    }

    public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer) {
      if (untypedValue == null) {
        serializer.Serialize(writer, null);
        return;
      }
      var value = (TypeEnum)untypedValue;
      if (value == TypeEnum.Official) {
        serializer.Serialize(writer, "official");
        return;
      } else if (value == TypeEnum.Bank) {
        serializer.Serialize(writer, "bank");
        return;
      }
      throw new Exception("Cannot marshal type TypeEnum");
    }

    public static readonly TypeEnumConverter Singleton = new TypeEnumConverter();
  }
}
